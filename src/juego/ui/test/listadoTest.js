// src/ui/combate/test/listadoTest.js

const test = {
  tier1: [
    {
      id: "T1-001",
      tier: 1,
      pregunta: "¿Cuál es el resultado de 7 + 5?",
      opciones: ["10", "11", "12", "13"],
      respuesta: 2,
      feedbackOk: "Correcto: 7 + 5 = 12.",
      feedbackFail: "Corrección: 7 + 5 es 12 (suma básica).",
    },
    {
      id: "T1-002",
      tier: 1,
      pregunta: "¿Qué planeta es conocido como el 'planeta rojo'?",
      opciones: ["Venus", "Marte", "Júpiter", "Mercurio"],
      respuesta: 1,
      feedbackOk: "Bien: Marte es llamado el planeta rojo.",
      feedbackFail: "Corrección: es Marte, por su color rojizo debido al óxido de hierro.",
    },
    {
      id: "T1-003",
      tier: 1,
      pregunta: "¿Cuál es la capital de Colombia?",
      opciones: ["Medellín", "Cali", "Bogotá", "Cartagena"],
      respuesta: 2,
      feedbackOk: "Correcto: la capital es Bogotá.",
      feedbackFail: "Corrección: la capital de Colombia es Bogotá.",
    },
    {
      id: "T1-004",
      tier: 1,
      pregunta: "¿Cuál es el resultado de 9 × 3?",
      opciones: ["18", "21", "27", "30"],
      respuesta: 2,
      feedbackOk: "Correcto: 9 × 3 = 27.",
      feedbackFail: "Corrección: 9 × 3 es 27 (multiplicación básica).",
    },
    {
      id: "T1-005",
      tier: 1,
      pregunta: "¿Cuántos minutos tiene una hora?",
      opciones: ["30", "45", "60", "90"],
      respuesta: 2,
      feedbackOk: "Bien: 1 hora = 60 minutos.",
      feedbackFail: "Corrección: una hora tiene 60 minutos.",
    },
    {
      id: "T1-006",
      tier: 1,
      pregunta: "¿Qué figura geométrica tiene 3 lados?",
      opciones: ["Cuadrado", "Triángulo", "Pentágono", "Círculo"],
      respuesta: 1,
      feedbackOk: "Correcto: el triángulo tiene 3 lados.",
      feedbackFail: "Corrección: el triángulo es la figura de 3 lados.",
    },
    {
      id: "T1-007",
      tier: 1,
      pregunta: "¿Qué color resulta de mezclar azul y amarillo?",
      opciones: ["Rojo", "Verde", "Morado", "Naranja"],
      respuesta: 1,
      feedbackOk: "Bien: azul + amarillo = verde.",
      feedbackFail: "Corrección: la mezcla de azul y amarillo da verde.",
    },
    {
      id: "T1-008",
      tier: 1,
      pregunta: "¿Cuál es el resultado de 15 - 6?",
      opciones: ["7", "8", "9", "10"],
      respuesta: 2,
      feedbackOk: "Correcto: 15 - 6 = 9.",
      feedbackFail: "Corrección: 15 menos 6 es 9.",
    },
    {
      id: "T1-009",
      tier: 1,
      pregunta: "¿Qué animal ladra?",
      opciones: ["Gato", "Perro", "Vaca", "Caballo"],
      respuesta: 1,
      feedbackOk: "Correcto: el perro ladra.",
      feedbackFail: "Corrección: quien ladra es el perro.",
    },
    {
      id: "T1-010",
      tier: 1,
      pregunta: "¿Cuál es el primer mes del año?",
      opciones: ["Diciembre", "Enero", "Febrero", "Marzo"],
      respuesta: 1,
      feedbackOk: "Bien: el primer mes es enero.",
      feedbackFail: "Corrección: el año inicia en enero.",
    },
    {
      id: "T1-011",
      tier: 1,
      pregunta: "¿Cuál es el resultado de 10 - 3?",
      opciones: ["5", "6", "7", "8"],
      respuesta: 2,
      feedbackOk: "Correcto: 10 - 3 = 7.",
      feedbackFail: "Corrección: 10 menos 3 es 7.",
    },
    {
      id: "T1-012",
      tier: 1,
      pregunta: "¿Qué día viene después del lunes?",
      opciones: ["Domingo", "Martes", "Miércoles", "Viernes"],
      respuesta: 1,
      feedbackOk: "Correcto: después del lunes viene martes.",
      feedbackFail: "Corrección: la secuencia es lunes → martes.",
    },
    {
      id: "T1-013",
      tier: 1,
      pregunta: "¿Cuál es el resultado de 4 × 4?",
      opciones: ["8", "12", "16", "20"],
      respuesta: 2,
      feedbackOk: "Bien: 4 × 4 = 16.",
      feedbackFail: "Corrección: 4 por 4 es 16.",
    },
    {
      id: "T1-014",
      tier: 1,
      pregunta: "¿Cuál es el resultado de 20 / 5?",
      opciones: ["2", "3", "4", "5"],
      respuesta: 2,
      feedbackOk: "Correcto: 20 / 5 = 4.",
      feedbackFail: "Corrección: 20 dividido en 5 partes da 4.",
    },
    {
      id: "T1-015",
      tier: 1,
      pregunta: "¿Qué parte del cuerpo se usa para oler?",
      opciones: ["Ojos", "Nariz", "Boca", "Orejas"],
      respuesta: 1,
      feedbackOk: "Correcto: se usa la nariz para oler.",
      feedbackFail: "Corrección: el olfato está en la nariz.",
    },
    {
      id: "T1-016",
      tier: 1,
      pregunta: "¿Cuál es el resultado de 3 + 3 + 3?",
      opciones: ["6", "7", "8", "9"],
      respuesta: 3,
      feedbackOk: "Bien: 3 + 3 + 3 = 9.",
      feedbackFail: "Corrección: sumar 3 tres veces da 9.",
    },
    {
      id: "T1-017",
      tier: 1,
      pregunta: "¿Qué número es mayor?",
      opciones: ["18", "21", "19", "20"],
      respuesta: 1,
      feedbackOk: "Correcto: 21 es el mayor.",
      feedbackFail: "Corrección: entre esas opciones, 21 es el número más grande.",
    },
    {
      id: "T1-018",
      tier: 1,
      pregunta: "¿Cuál es el resultado de 6 × 2?",
      opciones: ["10", "11", "12", "14"],
      respuesta: 2,
      feedbackOk: "Correcto: 6 × 2 = 12.",
      feedbackFail: "Corrección: 6 por 2 es 12.",
    },
    {
      id: "T1-019",
      tier: 1,
      pregunta: "¿Cuántos lados tiene un cuadrado?",
      opciones: ["3", "4", "5", "6"],
      respuesta: 1,
      feedbackOk: "Bien: un cuadrado tiene 4 lados.",
      feedbackFail: "Corrección: el cuadrado siempre tiene 4 lados iguales.",
    },
    {
      id: "T1-020",
      tier: 1,
      pregunta: "¿Cuál es el resultado de 9 + 1?",
      opciones: ["8", "9", "10", "11"],
      respuesta: 2,
      feedbackOk: "Correcto: 9 + 1 = 10.",
      feedbackFail: "Corrección: sumar 1 a 9 da 10.",
    },
  ],

  tier2: [
    {
      id: "T2-001",
      tier: 2,
      pregunta: "En Unity, ¿qué componente se usa para detectar colisiones físicas?",
      opciones: ["Renderer", "Collider", "Canvas", "AudioSource"],
      respuesta: 1,
      feedbackOk: "Correcto: los Colliders definen el volumen de colisión.",
      feedbackFail: "Corrección: se usa un Collider para colisiones (Box/Sphere/Capsule, etc.).",
    },
    {
      id: "T2-002",
      tier: 2,
      pregunta: "¿Cuál método de Unity se llama una sola vez al iniciar el objeto (si está activo)?",
      opciones: ["Update()", "FixedUpdate()", "Start()", "OnGUI()"],
      respuesta: 2,
      feedbackOk: "Bien: Start() se ejecuta una vez al comienzo (tras Awake, antes del primer Update).",
      feedbackFail: "Corrección: Start() se llama una vez al iniciar, si el componente está habilitado.",
    },
    {
      id: "T2-003",
      tier: 2,
      pregunta: "¿Cuál método de Unity se ejecuta una vez por frame?",
      opciones: ["Update()", "Start()", "Awake()", "OnEnable()"],
      respuesta: 0,
      feedbackOk: "Correcto: Update() corre una vez por frame.",
      feedbackFail: "Corrección: Update() es el ciclo por frame para lógica general.",
    },
    {
      id: "T2-004",
      tier: 2,
      pregunta: "¿Cuál método se recomienda para lógica de física (Rigidbody) en Unity?",
      opciones: ["Update()", "FixedUpdate()", "LateUpdate()", "OnValidate()"],
      respuesta: 1,
      feedbackOk: "Bien: FixedUpdate() se sincroniza con el paso fijo de física.",
      feedbackFail: "Corrección: FixedUpdate() es el recomendado para fuerzas/movimiento con Rigidbody.",
    },
    {
      id: "T2-005",
      tier: 2,
      pregunta: "¿Qué es un Prefab en Unity?",
      opciones: [
        "Una escena comprimida",
        "Una plantilla reutilizable de GameObject",
        "Un material de iluminación",
        "Un script de UI",
      ],
      respuesta: 1,
      feedbackOk: "Correcto: un Prefab es una plantilla instanciable y reutilizable.",
      feedbackFail: "Corrección: un Prefab guarda un GameObject (y sus componentes) como plantilla.",
    },
    {
      id: "T2-006",
      tier: 2,
      pregunta: "¿Dónde se organizan los objetos que existen dentro de una escena?",
      opciones: ["Project", "Hierarchy", "Inspector", "Console"],
      respuesta: 1,
      feedbackOk: "Bien: Hierarchy lista los GameObjects de la escena.",
      feedbackFail: "Corrección: en Hierarchy se ven y ordenan los objetos de la escena.",
    },
    {
      id: "T2-007",
      tier: 2,
      pregunta: "¿Qué ventana muestra y permite editar los componentes del objeto seleccionado?",
      opciones: ["Project", "Hierarchy", "Inspector", "Scene"],
      respuesta: 2,
      feedbackOk: "Correcto: en Inspector editas componentes y propiedades.",
      feedbackFail: "Corrección: Inspector es donde configuras el GameObject seleccionado.",
    },
    {
      id: "T2-008",
      tier: 2,
      pregunta: "¿Qué es un GameObject en Unity?",
      opciones: [
        "Un archivo de audio",
        "Un objeto base al que se le agregan componentes",
        "Un tipo de shader",
        "Un sistema de partículas",
      ],
      respuesta: 1,
      feedbackOk: "Bien: un GameObject es el contenedor base de componentes.",
      feedbackFail: "Corrección: GameObject es la base; su comportamiento viene de componentes.",
    },
    {
      id: "T2-009",
      tier: 2,
      pregunta: "¿Qué componente permite mover un objeto con física en Unity?",
      opciones: ["Transform", "Rigidbody", "MeshFilter", "Animator"],
      respuesta: 1,
      feedbackOk: "Correcto: Rigidbody habilita simulación física y fuerzas.",
      feedbackFail: "Corrección: Rigidbody se usa para movimiento físico (fuerzas, gravedad, colisiones).",
    },
    {
      id: "T2-010",
      tier: 2,
      pregunta: "¿Qué es una Scene (escena) en Unity?",
      opciones: [
        "Un conjunto de GameObjects y configuración del nivel",
        "Una textura para el terreno",
        "Un script de movimiento",
        "Un Prefab especial",
      ],
      respuesta: 0,
      feedbackOk: "Bien: la escena contiene objetos y configuración del nivel.",
      feedbackFail: "Corrección: una Scene es el contenedor del nivel/entorno y sus GameObjects.",
    },
    {
      id: "T2-011",
      tier: 2,
      pregunta: "¿Qué se usa para mostrar UI tradicional en Unity (UGUI)?",
      opciones: ["Canvas", "MeshRenderer", "Rigidbody", "Collider"],
      respuesta: 0,
      feedbackOk: "Correcto: la UI de UGUI vive dentro de un Canvas.",
      feedbackFail: "Corrección: Canvas es el contenedor de elementos UI (Text, Image, Button).",
    },
    {
      id: "T2-012",
      tier: 2,
      pregunta: "¿Qué componente se usa para reproducir sonidos en un GameObject?",
      opciones: ["AudioSource", "AudioListener", "Animator", "Light"],
      respuesta: 0,
      feedbackOk: "Bien: AudioSource reproduce clips de audio.",
      feedbackFail: "Corrección: AudioSource es el que reproduce; AudioListener es el “oído” (cámara).",
    },
    {
      id: "T2-013",
      tier: 2,
      pregunta: "¿Qué ocurre si desactivas un GameObject (SetActive(false))?",
      opciones: [
        "Se destruye y no puede volver",
        "Deja de ejecutarse y no se renderiza mientras esté inactivo",
        "Se convierte en Prefab",
        "Se guarda automáticamente en Project",
      ],
      respuesta: 1,
      feedbackOk: "Correcto: al estar inactivo no ejecuta scripts ni se renderiza.",
      feedbackFail: "Corrección: SetActive(false) lo oculta y deshabilita su ejecución hasta reactivarlo.",
    },
    {
      id: "T2-014",
      tier: 2,
      pregunta: "¿Qué significa 'Tag' en Unity?",
      opciones: [
        "Una capa de física",
        "Una etiqueta para identificar objetos por nombre lógico",
        "Un tipo de script",
        "Un shader de post-proceso",
      ],
      respuesta: 1,
      feedbackOk: "Bien: Tag ayuda a identificar objetos (CompareTag).",
      feedbackFail: "Corrección: Tag es una etiqueta para clasificar/identificar objetos por lógica.",
    },
    {
      id: "T2-015",
      tier: 2,
      pregunta: "¿Cuál es la diferencia principal entre Tag y Layer?",
      opciones: [
        "No hay diferencia",
        "Layer se usa para colisiones/visibilidad; Tag para identificar objetos",
        "Tag es para físicas y Layer para nombres",
        "Layer solo aplica a UI",
      ],
      respuesta: 1,
      feedbackOk: "Correcto: Layer se usa para filtros (física/cámara), Tag para identificar.",
      feedbackFail: "Corrección: Layer sirve para máscaras (Raycast/cámara/colisiones); Tag es etiqueta lógica.",
    },
    {
      id: "T2-016",
      tier: 2,
      pregunta: "¿Qué clase se usa típicamente como base para scripts en Unity?",
      opciones: ["MonoBehaviour", "ScriptableObject", "GameManager", "Transform"],
      respuesta: 0,
      feedbackOk: "Bien: MonoBehaviour habilita el ciclo de vida (Awake/Start/Update).",
      feedbackFail: "Corrección: MonoBehaviour es la base típica para scripts en GameObjects.",
    },
    {
      id: "T2-017",
      tier: 2,
      pregunta: "¿Qué método se llama antes de Start() y se usa para inicializaciones tempranas?",
      opciones: ["Awake()", "LateUpdate()", "OnDestroy()", "OnCollisionExit()"],
      respuesta: 0,
      feedbackOk: "Correcto: Awake() se ejecuta muy temprano al cargar el objeto.",
      feedbackFail: "Corrección: Awake() corre antes de Start(); útil para referencias/inicialización base.",
    },
    {
      id: "T2-018",
      tier: 2,
      pregunta: "¿Qué se usa para cargar una escena por código?",
      opciones: ["SceneManager.LoadScene()", "GameObject.Load()", "Prefab.Load()", "Level.Load()"],
      respuesta: 0,
      feedbackOk: "Bien: SceneManager.LoadScene() carga escenas por nombre o índice.",
      feedbackFail: "Corrección: se usa SceneManager.LoadScene() (UnityEngine.SceneManagement).",
    },
    {
      id: "T2-019",
      tier: 2,
      pregunta: "¿Qué es un ScriptableObject en Unity?",
      opciones: [
        "Un componente de física",
        "Un asset para datos/configuración que no depende de una escena",
        "Una escena empaquetada",
        "Un tipo de UI",
      ],
      respuesta: 1,
      feedbackOk: "Correcto: ScriptableObject es ideal para data/config sin depender de escenas.",
      feedbackFail: "Corrección: ScriptableObject es un asset para guardar datos reutilizables.",
    },
    {
      id: "T2-020",
      tier: 2,
      pregunta: "¿Qué herramienta se usa para ver errores y logs en Unity?",
      opciones: ["Inspector", "Console", "Hierarchy", "Animator"],
      respuesta: 1,
      feedbackOk: "Bien: Console muestra logs, warnings y errores.",
      feedbackFail: "Corrección: la ventana Console es donde se ven Debug.Log y errores.",
    },
  ],

  tier3: [
    {
      id: "T3-001",
      tier: 3,
      pregunta: "En C++, ¿qué significa RAII?",
      opciones: [
        "Run All Instructions Instantly",
        "Resource Acquisition Is Initialization",
        "Random Access Inheritance Interface",
        "Runtime Allocation Is Illegal",
      ],
      respuesta: 1,
      feedbackOk: "Correcto: RAII liga recursos al ciclo de vida de objetos (constructor/destructor).",
      feedbackFail: "Corrección: RAII significa Resource Acquisition Is Initialization (gestión automática de recursos).",
    },
    {
      id: "T3-002",
      tier: 3,
      pregunta: "¿Qué hace 'delete[]' en C++?",
      opciones: [
        "Libera memoria asignada con new para un solo objeto",
        "Libera memoria asignada con new[] para arreglos",
        "Resetea un puntero a nullptr",
        "Destruye un stack frame",
      ],
      respuesta: 1,
      feedbackOk: "Bien: delete[] se usa para memoria reservada con new[].",
      feedbackFail: "Corrección: delete[] libera arreglos creados con new[]; delete es para un solo objeto.",
    },
    {
      id: "T3-003",
      tier: 3,
      pregunta: "¿Qué es un 'dangling pointer'?",
      opciones: [
        "Un puntero a memoria ya liberada o inválida",
        "Un puntero constante",
        "Un puntero nulo",
        "Un puntero a una función",
      ],
      respuesta: 0,
      feedbackOk: "Correcto: apunta a memoria inválida (ya liberada o fuera de scope).",
      feedbackFail: "Corrección: dangling pointer es un puntero que quedó apuntando a memoria inválida.",
    },
    {
      id: "T3-004",
      tier: 3,
      pregunta: "¿Qué ventaja principal aporta std::unique_ptr?",
      opciones: [
        "Copia automática del recurso",
        "Propiedad exclusiva y liberación automática (RAII)",
        "Permite múltiples dueños del mismo recurso",
        "Evita el uso de destructores",
      ],
      respuesta: 1,
      feedbackOk: "Bien: unique_ptr expresa propiedad exclusiva y libera automáticamente.",
      feedbackFail: "Corrección: unique_ptr implementa RAII con propiedad exclusiva (no se copia, se mueve).",
    },
    {
      id: "T3-005",
      tier: 3,
      pregunta: "¿Qué contenedor de STL es típicamente O(1) para push_back amortizado?",
      opciones: ["std::list", "std::vector", "std::map", "std::set"],
      respuesta: 1,
      feedbackOk: "Correcto: std::vector tiene push_back amortizado O(1).",
      feedbackFail: "Corrección: vector crece por capacidad; por eso push_back es amortizado O(1).",
    },
    {
      id: "T3-006",
      tier: 3,
      pregunta: "¿Qué significa 'move semantics' en C++?",
      opciones: [
        "Mover variables entre hilos",
        "Transferir recursos sin copiar (usando rvalue references)",
        "Convertir int a float",
        "Optimizar bucles for",
      ],
      respuesta: 1,
      feedbackOk: "Bien: mover transfiere recursos sin copiar (más eficiente).",
      feedbackFail: "Corrección: move semantics usa rvalue references para transferir recursos (no copiar).",
    },
    {
      id: "T3-007",
      tier: 3,
      pregunta: "¿Qué es 'const correctness'?",
      opciones: [
        "Usar const para permitir cambios seguros",
        "Diseñar APIs donde const evita modificaciones no deseadas",
        "Eliminar la palabra const para rendimiento",
        "Usar const solo en macros",
      ],
      respuesta: 1,
      feedbackOk: "Correcto: const ayuda a garantizar qué se puede modificar y qué no.",
      feedbackFail: "Corrección: const correctness es diseñar para no modificar datos cuando no corresponde.",
    },
    {
      id: "T3-008",
      tier: 3,
      pregunta: "¿Cuál es la diferencia entre referencia y puntero en C++?",
      opciones: [
        "No hay diferencia",
        "Una referencia no puede ser null y se vincula al inicializar; un puntero sí puede ser null",
        "Un puntero siempre es más rápido",
        "Una referencia se puede reasignar, un puntero no",
      ],
      respuesta: 1,
      feedbackOk: "Bien: referencias se enlazan una vez; punteros pueden ser null y reasignarse.",
      feedbackFail: "Corrección: referencia no suele ser null y se inicializa al declarar; puntero puede ser null.",
    },
    {
      id: "T3-009",
      tier: 3,
      pregunta: "¿Qué hace 'virtual' en un método de C++?",
      opciones: [
        "Hace el método privado",
        "Permite despacho dinámico (polimorfismo en runtime)",
        "Evita el uso de punteros",
        "Convierte la clase en template",
      ],
      respuesta: 1,
      feedbackOk: "Correcto: virtual habilita polimorfismo con llamadas dinámicas.",
      feedbackFail: "Corrección: virtual permite que la llamada se resuelva en runtime según el tipo real.",
    },
    {
      id: "T3-010",
      tier: 3,
      pregunta: "¿Qué es una 'vtable'?",
      opciones: [
        "Una tabla de hashes estándar",
        "Estructura usada para resolver llamadas virtuales en runtime",
        "Un vector de enteros",
        "Un archivo de compilación",
      ],
      respuesta: 1,
      feedbackOk: "Bien: la vtable ayuda a resolver métodos virtuales en runtime.",
      feedbackFail: "Corrección: vtable es la estructura que soporta el despacho dinámico de funciones virtuales.",
    },
    {
      id: "T3-011",
      tier: 3,
      pregunta: "¿Qué ocurre si una clase tiene un destructor virtual?",
      opciones: [
        "No puede heredarse",
        "Asegura destrucción correcta al borrar vía puntero base",
        "Impide el uso de new",
        "Hace la clase abstracta automáticamente",
      ],
      respuesta: 1,
      feedbackOk: "Correcto: garantiza destrucción correcta al hacer delete mediante un puntero base.",
      feedbackFail: "Corrección: sin destructor virtual, delete vía base puede no llamar el destructor derivado.",
    },
    {
      id: "T3-012",
      tier: 3,
      pregunta: "¿Qué es SFINAE en C++?",
      opciones: [
        "Un tipo de puntero inteligente",
        "Una regla: Substitution Failure Is Not An Error (en templates)",
        "Un modo de compilación",
        "Una librería de IO",
      ],
      respuesta: 1,
      feedbackOk: "Bien: SFINAE permite habilitar/deshabilitar templates según tipos válidos.",
      feedbackFail: "Corrección: SFINAE significa que fallos de sustitución en templates no causan error duro.",
    },
    {
      id: "T3-013",
      tier: 3,
      pregunta: "¿Qué contenedor mantiene claves ordenadas automáticamente?",
      opciones: ["std::unordered_map", "std::vector", "std::map", "std::queue"],
      respuesta: 2,
      feedbackOk: "Correcto: std::map mantiene orden (árbol balanceado).",
      feedbackFail: "Corrección: map mantiene claves ordenadas; unordered_map no garantiza orden.",
    },
    {
      id: "T3-014",
      tier: 3,
      pregunta: "¿Qué significa 'undefined behavior' (UB) en C++?",
      opciones: [
        "El programa siempre crashea",
        "El estándar no define el resultado; puede pasar cualquier cosa",
        "El compilador lo corrige automáticamente",
        "Solo afecta a Windows",
      ],
      respuesta: 1,
      feedbackOk: "Bien: UB significa que no hay resultado garantizado por el estándar.",
      feedbackFail: "Corrección: undefined behavior es comportamiento no definido; puede funcionar, fallar o variar.",
    },
    {
      id: "T3-015",
      tier: 3,
      pregunta: "¿Cuál es el propósito de std::move?",
      opciones: [
        "Mover datos físicamente en memoria",
        "Convertir a rvalue para habilitar movimientos",
        "Copiar más rápido",
        "Eliminar un objeto del heap",
      ],
      respuesta: 1,
      feedbackOk: "Correcto: std::move convierte a rvalue para permitir mover.",
      feedbackFail: "Corrección: std::move no mueve por sí solo; habilita el movimiento al convertir a rvalue.",
    },
    {
      id: "T3-016",
      tier: 3,
      pregunta: "¿Qué es la 'Rule of Five'?",
      opciones: [
        "Cinco tipos de loops",
        "Constructor, destructor, copy/move ctor y copy/move assign",
        "Cinco palabras reservadas",
        "Cinco contenedores de STL",
      ],
      respuesta: 1,
      feedbackOk: "Bien: si manejas recursos, considera implementar/definir esos 5 miembros especiales.",
      feedbackFail: "Corrección: Rule of Five = dtor, copy/move ctor, copy/move assignment.",
    },
    {
      id: "T3-017",
      tier: 3,
      pregunta: "¿Qué es un 'lambda' en C++?",
      opciones: [
        "Una clase abstracta",
        "Una función anónima (objeto callable)",
        "Un tipo de puntero",
        "Un macro del preprocesador",
      ],
      respuesta: 1,
      feedbackOk: "Correcto: lambda es una función anónima con captura opcional.",
      feedbackFail: "Corrección: lambda crea un objeto callable (función anónima) que puede capturar variables.",
    },
    {
      id: "T3-018",
      tier: 3,
      pregunta: "¿Qué complejidad tiene buscar una clave en std::unordered_map (promedio)?",
      opciones: ["O(1)", "O(log n)", "O(n)", "O(n log n)"],
      respuesta: 0,
      feedbackOk: "Bien: en promedio es O(1) si el hash está bien distribuido.",
      feedbackFail: "Corrección: unordered_map es promedio O(1), pero puede degradar si hay muchas colisiones.",
    },
    {
      id: "T3-019",
      tier: 3,
      pregunta: "¿Qué es 'template specialization'?",
      opciones: [
        "Herencia múltiple",
        "Definir una implementación específica de un template para ciertos tipos",
        "Optimizar el compilador",
        "Eliminar warnings",
      ],
      respuesta: 1,
      feedbackOk: "Correcto: specialization adapta un template para tipos concretos.",
      feedbackFail: "Corrección: specialization permite una versión específica del template para ciertos tipos.",
    },
    {
      id: "T3-020",
      tier: 3,
      pregunta: "¿Qué hace 'constexpr' en C++ (idea principal)?",
      opciones: [
        "Ejecuta código en la GPU",
        "Permite evaluación en tiempo de compilación cuando es posible",
        "Desactiva optimizaciones",
        "Convierte a const automáticamente",
      ],
      respuesta: 1,
      feedbackOk: "Bien: constexpr habilita cálculos en compile-time cuando aplica.",
      feedbackFail: "Corrección: constexpr permite que el compilador evalúe expresiones en tiempo de compilación.",
    },
  ],
};

export default test;
